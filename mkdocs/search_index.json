{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\n\n\n\nWhat is libsoc\n\n\nlibsoc is a C library to interface with common peripherals found in\nSystem on Chips (SoC) through generic Linux Kernel interfaces.\n\n\nIt is aimed at new Linux users, and intends to be a stepping stone to\nenable a user to get started quickly. It is optimised for reliability\nrather than speed. While the library should be fast, no guarantees are\nmade on it's determinism and it should not be used in time critical\nroutines.\n\n\nWhy libsoc\n\n\nlibsoc was born due to the influx of new embedded Linux boards becoming\navailable cheap, and to hobbyists. There are currently numerous\nlibraries that do interfacing with common SoC peripherals, but they all\ntend to be centred around a particular board or SoC. This leads to board\nspecific hacks and in some cases direct bypassing of the Linux Kernel.\n\n\nlibsoc aims to be generic and compatible with any SoC that has drivers\nexposing the correct interfaces for the defined peripheral.\n\n\nSupport\n\n\n\n\nSoC Support\n\n\nIf your SoC exposes it's I/O subsystems using the generic Linux kernel\ninterfaces then yes, libsoc supports your SoC!\n\n\nLanguage Support\n\n\nThe library is written in C and has a native C API. A subset of the API\nis also supported with Python bindings.\n\n\nC API\n\n\n\n\nManual GPIO Manipulation through sysfs (Value, Edge, Direction, Exporting)\n\n\nBlocking GPIO Interrupts with timeout\n\n\nNon-blocking GPIO Interrupts with callback mechanism (pthread based)\n\n\nSPI transfers using spidev\n\n\nI2C transfers using ioctls\n\n\nPWM support through sysfs (Linux 3.12+)\n\n\nAutomatic board probing via installed config files\n\n\n\n\nPython Bindings\n\n\n\n\nManual GPIO Manipulation through sysfs (Value, Edge, Direction, Exporting)\n\n\nBlocking GPIO Interrupts with timeout\n\n\nNon-blocking GPIO Interrupts with callback mechanism\n\n\nI2C transfers\n\n\n\n\nBuilding\n\n\n\n\nlibsoc is built and installed using the autotools build system. This means it\nfollows the traditional linux methodology of autoreconf, configure, make.\n\n\nFirst, check if your distro packages libsoc. If it does it is easiest to install\nyour distros version of libsoc through it's provided package manager. Depending\non your distro this may be \napt-get\n, \nyum\n, \npacman\n, etc. Consult your distro\ndocumentation for more info.\n\n\nManually Building\n\n\nFirst clone libsoc from its git repository.\n\n\ngit clone https://github.com/jackmitch/libsoc.git libsoc.git\n\n\n\nEnter the libsoc.git directory\n\n\ncd libsoc.git\n\n\n\nRun \nautoreconf\n to generate the libsoc configure scripts\n\n\nautoreconf -i\n\n\n\nConfigure the libsoc library with the required features\n\n\n./configure\n\n    [--disable-debug]\n    [--enable-python=<path|version>]\n    [--enable-board=<board>]\n    [--with-board-configs]\n\n\n\n\n--disable-debug\n\ndisables the debug code, turn off the debug to\nget the fastest operation but at the cost of any\ndebug print outs. Omitting this flag will leave\ndebug enabled.\n\n\n\n\n--enable-python=<path|version>\n\nenable Python language bindings to libsoc API.\nValue can be empty for autodetect, the value 2\nor 3 to search the PATH environment variable\nfor python2 or python3, or an absolute path to\na python binary.\n\n\n\n\n--enable-board=<board>\n\ninstall a specific board config file to\n$(sysdir)/libsoc.conf. This enables the use of\nthe board pin name lookup functions and\nautomatic board config probing. Supported boards\ncan be found under ./contrib/board_files. If\n--with-board-configs is also used, a symlink\nwill be created instead of copying a single file.\n\n\n\n\n--with-board-configs\n\ninstall all the contributed board configuration\nfiles to $PREFIX/share/libsoc.\n\n\n\n\nCompile the code using make\n\n\nmake\n\n\n\n\nInstall the library using make\n\n\nmake install\n\n\n\n\nDocumentation\n\n\nWritten documentation can be found at\n\nhttp://jackmitch.github.io/libsoc\n.\n\n\nTest cases can be found in the \n\ntest/\n directory\nfrom the root of the project.\n\n\nAll functions and types are also documented directly in the code in the\napplication header files under\n\nlib/include\n.\n\n\nLicencing\n\n\nlibsoc is licenced under the LGPLv2.1, please see the COPYING file for\nfurther details.\n\n\nContributing\n\n\nlibsoc is open-source software and as such you are welcome to browse the\ncode and either add features, or fix bugs. Please submit pull requests,\nand bugs to \nlibsoc@github\n.\nIf you have any comments or questions, I can be contacted by email at the\naddress \njack@embed.me.uk\n.",
            "title": "Introduction"
        },
        {
            "location": "/#introduction",
            "text": "",
            "title": "Introduction"
        },
        {
            "location": "/#what-is-libsoc",
            "text": "libsoc is a C library to interface with common peripherals found in\nSystem on Chips (SoC) through generic Linux Kernel interfaces.  It is aimed at new Linux users, and intends to be a stepping stone to\nenable a user to get started quickly. It is optimised for reliability\nrather than speed. While the library should be fast, no guarantees are\nmade on it's determinism and it should not be used in time critical\nroutines.",
            "title": "What is libsoc"
        },
        {
            "location": "/#why-libsoc",
            "text": "libsoc was born due to the influx of new embedded Linux boards becoming\navailable cheap, and to hobbyists. There are currently numerous\nlibraries that do interfacing with common SoC peripherals, but they all\ntend to be centred around a particular board or SoC. This leads to board\nspecific hacks and in some cases direct bypassing of the Linux Kernel.  libsoc aims to be generic and compatible with any SoC that has drivers\nexposing the correct interfaces for the defined peripheral.",
            "title": "Why libsoc"
        },
        {
            "location": "/#support",
            "text": "",
            "title": "Support"
        },
        {
            "location": "/#soc-support",
            "text": "If your SoC exposes it's I/O subsystems using the generic Linux kernel\ninterfaces then yes, libsoc supports your SoC!",
            "title": "SoC Support"
        },
        {
            "location": "/#language-support",
            "text": "The library is written in C and has a native C API. A subset of the API\nis also supported with Python bindings.",
            "title": "Language Support"
        },
        {
            "location": "/#c-api",
            "text": "Manual GPIO Manipulation through sysfs (Value, Edge, Direction, Exporting)  Blocking GPIO Interrupts with timeout  Non-blocking GPIO Interrupts with callback mechanism (pthread based)  SPI transfers using spidev  I2C transfers using ioctls  PWM support through sysfs (Linux 3.12+)  Automatic board probing via installed config files",
            "title": "C API"
        },
        {
            "location": "/#python-bindings",
            "text": "Manual GPIO Manipulation through sysfs (Value, Edge, Direction, Exporting)  Blocking GPIO Interrupts with timeout  Non-blocking GPIO Interrupts with callback mechanism  I2C transfers",
            "title": "Python Bindings"
        },
        {
            "location": "/#building",
            "text": "libsoc is built and installed using the autotools build system. This means it\nfollows the traditional linux methodology of autoreconf, configure, make.  First, check if your distro packages libsoc. If it does it is easiest to install\nyour distros version of libsoc through it's provided package manager. Depending\non your distro this may be  apt-get ,  yum ,  pacman , etc. Consult your distro\ndocumentation for more info.",
            "title": "Building"
        },
        {
            "location": "/#manually-building",
            "text": "First clone libsoc from its git repository.  git clone https://github.com/jackmitch/libsoc.git libsoc.git  Enter the libsoc.git directory  cd libsoc.git  Run  autoreconf  to generate the libsoc configure scripts  autoreconf -i  Configure the libsoc library with the required features  ./configure\n\n    [--disable-debug]\n    [--enable-python=<path|version>]\n    [--enable-board=<board>]\n    [--with-board-configs]  --disable-debug\n\ndisables the debug code, turn off the debug to\nget the fastest operation but at the cost of any\ndebug print outs. Omitting this flag will leave\ndebug enabled.  --enable-python=<path|version>\n\nenable Python language bindings to libsoc API.\nValue can be empty for autodetect, the value 2\nor 3 to search the PATH environment variable\nfor python2 or python3, or an absolute path to\na python binary.  --enable-board=<board>\n\ninstall a specific board config file to\n$(sysdir)/libsoc.conf. This enables the use of\nthe board pin name lookup functions and\nautomatic board config probing. Supported boards\ncan be found under ./contrib/board_files. If\n--with-board-configs is also used, a symlink\nwill be created instead of copying a single file.  --with-board-configs\n\ninstall all the contributed board configuration\nfiles to $PREFIX/share/libsoc.  Compile the code using make  make  Install the library using make  make install",
            "title": "Manually Building"
        },
        {
            "location": "/#documentation",
            "text": "Written documentation can be found at http://jackmitch.github.io/libsoc .  Test cases can be found in the  test/  directory\nfrom the root of the project.  All functions and types are also documented directly in the code in the\napplication header files under lib/include .",
            "title": "Documentation"
        },
        {
            "location": "/#licencing",
            "text": "libsoc is licenced under the LGPLv2.1, please see the COPYING file for\nfurther details.",
            "title": "Licencing"
        },
        {
            "location": "/#contributing",
            "text": "libsoc is open-source software and as such you are welcome to browse the\ncode and either add features, or fix bugs. Please submit pull requests,\nand bugs to  libsoc@github .\nIf you have any comments or questions, I can be contacted by email at the\naddress  jack@embed.me.uk .",
            "title": "Contributing"
        },
        {
            "location": "/c/gpio/",
            "text": "GPIO\n\n\n\n\nData Types\n\n\n\n\ngpio_mode\n\n\nDetermines the way in which libsoc handles exporting and unexporting\nGPIOs in the Linux subsystem.\n\n\n\n\n\n\nLS_SHARED\n\n\nif the gpio is already exported then it will not unexport\nthe GPIO on free. If it is not exported, then it will\nunexport on free.\n\n\n\n\n\n\nLS_GREEDY\n\n\nwill succeed if the GPIO is already exported, but will \nalways unexport the GPIO on free.\n\n\n\n\n\n\nLS_WEAK\n\n\nwill fail if GPIO is already exported, will always unexport\non free.\n\n\n\n\n\n\n\n\ngpio_direction\n\n\nUsed for setting and reading the direction of the GPIO pin.\n\n\n\n\n\n\nDIRECTION_ERROR\n\n\nReturned when the GPIO direction could not be read\n\n\n\n\n\n\nINPUT\n\n\nGPIO input mode, it's input value can be read\n\n\n\n\n\n\nOUTPUT\n\n\nGPIO output mode, it's output value can be written\n\n\n\n\n\n\n\n\ngpio_level\n\n\nUsed for setting and reading the level of the GPIO pin.\n\n\n\n\n\n\nLEVEL_ERROR\n\n\nReturned when the GPIO level could not be read\n\n\n\n\n\n\nLOW\n\n\nGPIO value low, usually logic 0 on the pin, but could be 1 if\nthe gpio is inverted.\n\n\n\n\n\n\nHIGH\n\n\nGPIO value high, usually logic 1 on the pin, but could be 0 if\nthe gpio is inverted.\n\n\n\n\n\n\n\n\ngpio_edge\n\n\nUsed for setting and reading the edge of the GPIO pin.\n\n\n\n\n\n\nEDGE_ERROR\n\n\nReturned when the GPIO edge could not be read\n\n\n\n\n\n\nRISING\n\n\nGPIO interrupt is triggered on a rising edge, e.g. logic level\n0 followed by 1\n\n\n\n\n\n\nFALLING\n\n\nGPIO interrupt is triggered on a falling edge, e.g. logic level\n1 followed by 0\n\n\n\n\n\n\nNONE\n\n\nGPIO interrupt edge is not set\n\n\n\n\n\n\nBOTH\n\n\nGPIO interrupt is triggered on both a falling and rising edge\n\n\n\n\n\n\n\n\ngpio_int_ret\n\n\nReturn type for blocked GPIO interrupts.\n\n\n\n\n\n\nLS_INT_ERROR\n\n\nError condition\n\n\n\n\n\n\nLS_INT_TRIGGERED\n\n\nInterrupt was triggered\n\n\n\n\n\n\nLS_INT_TIMEOUT\n\n\nGPIO poll timedout\n\n\n\n\n\n\nFunctions\n\n\n\n\nlibsoc_gpio_request\n\n\ngpio * libsoc_gpio_request(unsigned int gpio_id, gpio_mode mode)\n\n\n\n\n\n\n\n\nunsigned int\n \ngpio_id\n\n\nthe Linux ID number for the GPIO you wish to use\n\n\n\n\n\n\ngpio_mode\n \nmode\n\n\nthe mode in which libsoc handles the GPIO file descriptor\n\n\n\n\n\n\nRequest a GPIO by it's Linux ID number and set the \ngpio_mode\n\nunder which libsoc will hold the file descriptor. Returns a malloced gpio struct\nwhich will need to be freed by \nlibsoc_gpio_free\n when no\nlonger needed.\n\n\nReturns \nNULL\n on failure.\n\n\n\n\nlibsoc_gpio_free\n\n\nint libsoc_gpio_free(gpio * gpio)\n\n\n\n\n\n\n\n\ngpioi*\n \ngpio\n\n\nthe previously requested gpio that you wish to release\n\n\n\n\n\n\nFree the memory associated with a previously requested GPIO and close the file\ndescriptors.\n\n\nReturns \nEXIT_SUCCESS\n/\nEXIT_FAILURE\n\n\n\n\nlibsoc_gpio_set_direction\n\n\nint libsoc_gpio_set_direction(gpio * current_gpio, gpio_direction direction)\n\n\n\n\n\n\n\n\ngpio*\n \ncurrent_gpio\n\n\nrequested gpio that you wish to set the direction of\n\n\n\n\n\n\ngpio_direction\n \ndirection\n\n\ndirection you wish to set the gpio to\n\n\n\n\n\n\nSet the direction of a GPIO, \nINPUT\n for reading a GPIO, \nOUTPUT\n for setting a\nGPIO.\n\n\nReturns \nEXIT_SUCCESS\n/\nEXIT_FAILURE\n\n\n\n\nlibsoc_gpio_get_direction\n\n\ngpio_direction libsoc_gpio_get_direction(gpio * current_gpio)\n\n\n\n\n\n\n\n\ngpio*\n \ncurrent_gpio\n\n\nrequested gpio that you wish to get the direction of\n\n\n\n\n\n\nGet the current \ngpio_direction\n of a requested GPIO.\n\n\nReturns \ngpio_direction\n, \nDIRECTION_ERROR\n on failure,\n\nINPUT\n/\nOUTPUT\n on success.\n\n\n\n\nlibsoc_gpio_set_level\n\n\nint libsoc_gpio_set_level(gpio * current_gpio, gpio_level level)\n\n\n\n\n\n\n\n\ngpio *\n \ncurrent_gpio\n\n\nrequested gpio you wish to set the level of\n\n\n\n\n\n\ngpio_level\n \nlevel\n\n\nlevel you wish to set the gpio to\n\n\n\n\n\n\nSet the output level of a requested GPIO to \nHIGH\n or \nLOW\n.\n\n\nReturns \nEXIT_SUCCESS\n/\nEXIT_FAILURE\n\n\n\n\nlibsoc_gpio_get_level\n\n\ngpio_level libsoc_gpio_get_level(gpio * current_gpio)\n\n\n\n\n\n\n\n\ngpio *\n \ncurrent_gpio\n\n\nrequested gpio you wish to get the level of\n\n\n\n\n\n\nGet the current \ngpio_level\n of a requested GPIO.\n\n\nReturns \ngpio_level\n, \nLEVEL_ERROR\n on failure,\n\nLOW\n/\nHIGH\n on success.\n\n\n\n\nlibsoc_gpio_set_edge\n\n\nint libsoc_gpio_set_edge(gpio * current_gpio, gpio_edge edge)\n\n\n\n\n\n\n\n\ngpio *\n \ncurrent_gpio\n\n\nrequested gpio you wish to set the edge of\n\n\n\n\n\n\ngpio_edge\n \nedge\n\n\nedge you wish to set the gpio to\n\n\n\n\n\n\nSet the edge type of a requested GPIO. The edge is the type of signal\nchange that will trigger interrupt detection. See \ngpio_edge\n\nfor explanations of the different types of edges and how they work.\n\n\nReturns \nEXIT_SUCCESS\n/\nEXIT_FAILURE\n\n\n\n\nlibsoc_gpio_get_edge\n\n\ngpio_edge libsoc_gpio_get_edge(gpio * current_gpio)\n\n\n\n\n\n\n\n\ngpio *\n \ncurrent_gpio\n\n\nrequested gpio you wish to get the edge of\n\n\n\n\n\n\nGet the current \ngpio_edge\n of a requested GPIO.\n\n\nReturns \ngpio_edge\n, \nEDGE_ERROR\n on failure,\n\nRISING\n/\nFALLING\n/\nBOTH\n/\nNONE\n on success.\n\n\n\n\nlibsoc_gpio_wait_interrupt\n\n\nint libsoc_gpio_wait_interrupt(gpio * gpio, int timeout)\n\n\n\n\n\n\n\n\ngpio *\n \ngpio\n\n\nrequested gpio you wish to wait for an interrupt on\n\n\n\n\n\n\nint\n \ntimeout\n\n\nthe number of seconds to wait for the interrupt, -1 for block indefinitly\n\n\n\n\n\n\nBlock for a set amount of seconds (or indefinitly) waiting for an interrupt on a\nGPIO to occur. If you wish to use a non-blocking interrupt mechanism see\n\nlibsoc_gpio_callback_interrupt\n.\n\n\nReturns \nLS_INT_ERROR\n on failure, \nLS_INT_TRIGGERED\n on captured interrupt,\n\nLS_INT_TIMEOUT\n if no interrupt was captured in the specified time.\n\n\n\n\nlibsoc_gpio_callback_interrupt\n\n\nint libsoc_gpio_callback_interrupt(gpio * gpio, int (*callback_fn) (void *), void *arg)\n\n\n\n\n\n\n\n\ngpio *\n \ngpio\n\n\nrequested gpio you wish to set an interrupt handler for\n\n\n\n\n\n\nint (*callback_fn) (void *)\n \nfunction\n\n\nname of the function to use as the interrupt handler. Must match the prototype\n\nint* function(void* ptr)\n\n\n\n\n\n\nvoid *\n \narg\n\n\nvoid casted pointer you wish to be passed to your interrupt handler\n\n\n\n\n\n\nSetup an interrupt handler on a GPIO. This will start a new pthread with an infinite poll\non the GPIO waiting for the interrupt. When an interrupt is detected the supplied function\nwill run in the thread, and then return to waiting for an interrupt.\n\n\nOnly one interrupt will be queued if it arrives while your supplied function is being run,\nso it is possible to miss interrupts if they happen too fast.\n\n\nReturns \nEXIT_SUCCESS\n/\nEXIT_FAILURE\n\n\n\n\nlibsoc_gpio_callback_interrupt_cancel\n\n\nint libsoc_gpio_callback_interrupt_cancel(gpio * gpio)\n\n\n\n\n\n\n\n\ngpio *\n \ngpio\n\n\nthe gpio on which to cancel a waiting interrupt handler\n\n\n\n\n\n\nCancel a previously set interrupt handler on a GPIO. This uses the pthread_cancel function,\nso it may cancel mid way through your interrupt handler function.\n\n\nReturns \nEXIT_SUCCESS\n/\nEXIT_FAILURE",
            "title": "GPIO"
        },
        {
            "location": "/c/gpio/#gpio",
            "text": "",
            "title": "GPIO"
        },
        {
            "location": "/c/gpio/#data-types",
            "text": "",
            "title": "Data Types"
        },
        {
            "location": "/c/gpio/#gpio_mode",
            "text": "Determines the way in which libsoc handles exporting and unexporting\nGPIOs in the Linux subsystem.    LS_SHARED  if the gpio is already exported then it will not unexport\nthe GPIO on free. If it is not exported, then it will\nunexport on free.    LS_GREEDY  will succeed if the GPIO is already exported, but will \nalways unexport the GPIO on free.    LS_WEAK  will fail if GPIO is already exported, will always unexport\non free.",
            "title": "gpio_mode"
        },
        {
            "location": "/c/gpio/#gpio_direction",
            "text": "Used for setting and reading the direction of the GPIO pin.    DIRECTION_ERROR  Returned when the GPIO direction could not be read    INPUT  GPIO input mode, it's input value can be read    OUTPUT  GPIO output mode, it's output value can be written",
            "title": "gpio_direction"
        },
        {
            "location": "/c/gpio/#gpio_level",
            "text": "Used for setting and reading the level of the GPIO pin.    LEVEL_ERROR  Returned when the GPIO level could not be read    LOW  GPIO value low, usually logic 0 on the pin, but could be 1 if\nthe gpio is inverted.    HIGH  GPIO value high, usually logic 1 on the pin, but could be 0 if\nthe gpio is inverted.",
            "title": "gpio_level"
        },
        {
            "location": "/c/gpio/#gpio_edge",
            "text": "Used for setting and reading the edge of the GPIO pin.    EDGE_ERROR  Returned when the GPIO edge could not be read    RISING  GPIO interrupt is triggered on a rising edge, e.g. logic level\n0 followed by 1    FALLING  GPIO interrupt is triggered on a falling edge, e.g. logic level\n1 followed by 0    NONE  GPIO interrupt edge is not set    BOTH  GPIO interrupt is triggered on both a falling and rising edge",
            "title": "gpio_edge"
        },
        {
            "location": "/c/gpio/#gpio_int_ret",
            "text": "Return type for blocked GPIO interrupts.    LS_INT_ERROR  Error condition    LS_INT_TRIGGERED  Interrupt was triggered    LS_INT_TIMEOUT  GPIO poll timedout",
            "title": "gpio_int_ret"
        },
        {
            "location": "/c/gpio/#functions",
            "text": "",
            "title": "Functions"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_request",
            "text": "gpio * libsoc_gpio_request(unsigned int gpio_id, gpio_mode mode)    unsigned int   gpio_id  the Linux ID number for the GPIO you wish to use    gpio_mode   mode  the mode in which libsoc handles the GPIO file descriptor    Request a GPIO by it's Linux ID number and set the  gpio_mode \nunder which libsoc will hold the file descriptor. Returns a malloced gpio struct\nwhich will need to be freed by  libsoc_gpio_free  when no\nlonger needed.  Returns  NULL  on failure.",
            "title": "libsoc_gpio_request"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_free",
            "text": "int libsoc_gpio_free(gpio * gpio)    gpioi*   gpio  the previously requested gpio that you wish to release    Free the memory associated with a previously requested GPIO and close the file\ndescriptors.  Returns  EXIT_SUCCESS / EXIT_FAILURE",
            "title": "libsoc_gpio_free"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_set_direction",
            "text": "int libsoc_gpio_set_direction(gpio * current_gpio, gpio_direction direction)    gpio*   current_gpio  requested gpio that you wish to set the direction of    gpio_direction   direction  direction you wish to set the gpio to    Set the direction of a GPIO,  INPUT  for reading a GPIO,  OUTPUT  for setting a\nGPIO.  Returns  EXIT_SUCCESS / EXIT_FAILURE",
            "title": "libsoc_gpio_set_direction"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_get_direction",
            "text": "gpio_direction libsoc_gpio_get_direction(gpio * current_gpio)    gpio*   current_gpio  requested gpio that you wish to get the direction of    Get the current  gpio_direction  of a requested GPIO.  Returns  gpio_direction ,  DIRECTION_ERROR  on failure, INPUT / OUTPUT  on success.",
            "title": "libsoc_gpio_get_direction"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_set_level",
            "text": "int libsoc_gpio_set_level(gpio * current_gpio, gpio_level level)    gpio *   current_gpio  requested gpio you wish to set the level of    gpio_level   level  level you wish to set the gpio to    Set the output level of a requested GPIO to  HIGH  or  LOW .  Returns  EXIT_SUCCESS / EXIT_FAILURE",
            "title": "libsoc_gpio_set_level"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_get_level",
            "text": "gpio_level libsoc_gpio_get_level(gpio * current_gpio)    gpio *   current_gpio  requested gpio you wish to get the level of    Get the current  gpio_level  of a requested GPIO.  Returns  gpio_level ,  LEVEL_ERROR  on failure, LOW / HIGH  on success.",
            "title": "libsoc_gpio_get_level"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_set_edge",
            "text": "int libsoc_gpio_set_edge(gpio * current_gpio, gpio_edge edge)    gpio *   current_gpio  requested gpio you wish to set the edge of    gpio_edge   edge  edge you wish to set the gpio to    Set the edge type of a requested GPIO. The edge is the type of signal\nchange that will trigger interrupt detection. See  gpio_edge \nfor explanations of the different types of edges and how they work.  Returns  EXIT_SUCCESS / EXIT_FAILURE",
            "title": "libsoc_gpio_set_edge"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_get_edge",
            "text": "gpio_edge libsoc_gpio_get_edge(gpio * current_gpio)    gpio *   current_gpio  requested gpio you wish to get the edge of    Get the current  gpio_edge  of a requested GPIO.  Returns  gpio_edge ,  EDGE_ERROR  on failure, RISING / FALLING / BOTH / NONE  on success.",
            "title": "libsoc_gpio_get_edge"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_wait_interrupt",
            "text": "int libsoc_gpio_wait_interrupt(gpio * gpio, int timeout)    gpio *   gpio  requested gpio you wish to wait for an interrupt on    int   timeout  the number of seconds to wait for the interrupt, -1 for block indefinitly    Block for a set amount of seconds (or indefinitly) waiting for an interrupt on a\nGPIO to occur. If you wish to use a non-blocking interrupt mechanism see libsoc_gpio_callback_interrupt .  Returns  LS_INT_ERROR  on failure,  LS_INT_TRIGGERED  on captured interrupt, LS_INT_TIMEOUT  if no interrupt was captured in the specified time.",
            "title": "libsoc_gpio_wait_interrupt"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_callback_interrupt",
            "text": "int libsoc_gpio_callback_interrupt(gpio * gpio, int (*callback_fn) (void *), void *arg)    gpio *   gpio  requested gpio you wish to set an interrupt handler for    int (*callback_fn) (void *)   function  name of the function to use as the interrupt handler. Must match the prototype int* function(void* ptr)    void *   arg  void casted pointer you wish to be passed to your interrupt handler    Setup an interrupt handler on a GPIO. This will start a new pthread with an infinite poll\non the GPIO waiting for the interrupt. When an interrupt is detected the supplied function\nwill run in the thread, and then return to waiting for an interrupt.  Only one interrupt will be queued if it arrives while your supplied function is being run,\nso it is possible to miss interrupts if they happen too fast.  Returns  EXIT_SUCCESS / EXIT_FAILURE",
            "title": "libsoc_gpio_callback_interrupt"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_callback_interrupt_cancel",
            "text": "int libsoc_gpio_callback_interrupt_cancel(gpio * gpio)    gpio *   gpio  the gpio on which to cancel a waiting interrupt handler    Cancel a previously set interrupt handler on a GPIO. This uses the pthread_cancel function,\nso it may cancel mid way through your interrupt handler function.  Returns  EXIT_SUCCESS / EXIT_FAILURE",
            "title": "libsoc_gpio_callback_interrupt_cancel"
        },
        {
            "location": "/c/spi/",
            "text": "",
            "title": "SPI (WIP)"
        },
        {
            "location": "/c/i2c/",
            "text": "",
            "title": "I2C (WIP)"
        },
        {
            "location": "/c/pwm/",
            "text": "",
            "title": "PWM (WIP)"
        },
        {
            "location": "/c/debug/",
            "text": "",
            "title": "DEBUG (WIP)"
        },
        {
            "location": "/python/",
            "text": "",
            "title": "Python Bindings (WIP)"
        }
    ]
}