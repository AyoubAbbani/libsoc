{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\n\n\n\nWhat is libsoc\n\n\nlibsoc is a C library to interface with common peripherals found in\nSystem on Chips (SoC) through generic Linux Kernel interfaces.\n\n\nIt is aimed at new Linux users, and intends to be a stepping stone to\nenable a user to get started quickly. It is optimised for reliability\nrather than speed. While the library should be fast, no guarantees are\nmade on it's determinism and it should not be used in time critical\nroutines.\n\n\nWhy libsoc\n\n\nlibsoc was born due to the influx of new embedded Linux boards becoming\navailable cheap, and to hobbyists. There are currently numerous\nlibraries that do interfacing with common SoC peripherals, but they all\ntend to be centred around a particular board or SoC. This leads to board\nspecific hacks and in some cases direct bypassing of the Linux Kernel.\n\n\nlibsoc aims to be generic and compatible with any SoC that has drivers\nexposing the correct interfaces for the defined peripheral.\n\n\nSupport\n\n\n\n\nSoC Support\n\n\nIf your SoC exposes it's I/O subsystems using the generic Linux kernel\ninterfaces then yes, libsoc supports your SoC!\n\n\nLanguage Support\n\n\nThe library is written in C and has a native C API. A subset of the API\nis also supported with Python bindings.\n\n\nC API\n\n\n\n\nManual GPIO Manipulation through sysfs (Value, Edge, Direction, Exporting)\n\n\nBlocking GPIO Interrupts with timeout\n\n\nNon-blocking GPIO Interrupts with callback mechanism (pthread based)\n\n\nSPI transfers using spidev\n\n\nI2C transfers using ioctls\n\n\nPWM support through sysfs (Linux 3.12+)\n\n\nAutomatic board probing via installed config files\n\n\n\n\nPython Bindings\n\n\n\n\nManual GPIO Manipulation through sysfs (Value, Edge, Direction, Exporting)\n\n\nBlocking GPIO Interrupts with timeout\n\n\nNon-blocking GPIO Interrupts with callback mechanism\n\n\nI2C transfers\n\n\n\n\nBuilding\n\n\n\n\nlibsoc is built and installed using the autotools build system. This means it\nfollows the traditional linux methodology of autoreconf, configure, make.\n\n\nFirst, check if your distro packages libsoc. If it does it is easiest to install\nyour distros version of libsoc through it's provided package manager. Depending\non your distro this may be \napt-get\n, \nyum\n, \npacman\n, etc. Consult your distro\ndocumentation for more info.\n\n\nManually Building\n\n\nFirst, make sure you have the prerequisites installed. Under Debian Jessie this\nmeans \nbuild-essential\n, \nautoconf\n, \nlibtool-bin\n and \npkg-config\n. You'll also\nneed \npython-dev\n or \npython3-dev\n, if you wish to install the python-bindings.\n\n\nThen, clone libsoc from its git repository.\n\n\ngit clone https://github.com/jackmitch/libsoc.git libsoc.git\n\n\n\nEnter the libsoc.git directory\n\n\ncd libsoc.git\n\n\n\nRun \nautoreconf\n to generate the libsoc configure scripts\n\n\nautoreconf -i\n\n\n\nConfigure the libsoc library with the required features\n\n\n./configure\n\n    [--disable-debug]\n    [--enable-python=<path|version>]\n    [--enable-board=<board>]\n    [--with-board-configs]\n\n\n\n\n--disable-debug\n\ndisables the debug code, turn off the debug to\nget the fastest operation but at the cost of any\ndebug print outs. Omitting this flag will leave\ndebug enabled.\n\n\n\n\n--enable-python=<path|version>\n\nenable Python language bindings to libsoc API.\nValue can be empty for autodetect, the value 2\nor 3 to search the PATH environment variable\nfor python2 or python3, or an absolute path to\na python binary.\n\n\n\n\n--enable-board=<board>\n\ninstall a specific board config file to\n$(sysdir)/libsoc.conf. This enables the use of\nthe board pin name lookup functions and\nautomatic board config probing. Supported boards\ncan be found under ./contrib/board_files. If\n--with-board-configs is also used, a symlink\nwill be created instead of copying a single file.\n\n\n\n\n--with-board-configs\n\ninstall all the contributed board configuration\nfiles to $PREFIX/share/libsoc.\n\n\n\n\nCompile the code using make\n\n\nmake\n\n\n\n\nInstall the library using make\n\n\nmake install\n\n\n\n\nDocumentation\n\n\nWritten documentation can be found at\n\nhttp://jackmitch.github.io/libsoc\n.\n\n\nTest cases can be found in the \n\ntest/\n directory\nfrom the root of the project.\n\n\nAll functions and types are also documented directly in the code in the\napplication header files under\n\nlib/include\n.\n\n\nLicencing\n\n\nlibsoc is licenced under the LGPLv2.1, please see the COPYING file for\nfurther details.\n\n\nContributing\n\n\nlibsoc is open-source software and as such you are welcome to browse the\ncode and either add features, or fix bugs. Please submit pull requests,\nand bugs to \nlibsoc@github\n.\nIf you have any comments or questions, I can be contacted by email at the\naddress \njack@embed.me.uk\n.",
            "title": "Introduction"
        },
        {
            "location": "/#introduction",
            "text": "",
            "title": "Introduction"
        },
        {
            "location": "/#what-is-libsoc",
            "text": "libsoc is a C library to interface with common peripherals found in\nSystem on Chips (SoC) through generic Linux Kernel interfaces.  It is aimed at new Linux users, and intends to be a stepping stone to\nenable a user to get started quickly. It is optimised for reliability\nrather than speed. While the library should be fast, no guarantees are\nmade on it's determinism and it should not be used in time critical\nroutines.",
            "title": "What is libsoc"
        },
        {
            "location": "/#why-libsoc",
            "text": "libsoc was born due to the influx of new embedded Linux boards becoming\navailable cheap, and to hobbyists. There are currently numerous\nlibraries that do interfacing with common SoC peripherals, but they all\ntend to be centred around a particular board or SoC. This leads to board\nspecific hacks and in some cases direct bypassing of the Linux Kernel.  libsoc aims to be generic and compatible with any SoC that has drivers\nexposing the correct interfaces for the defined peripheral.",
            "title": "Why libsoc"
        },
        {
            "location": "/#support",
            "text": "",
            "title": "Support"
        },
        {
            "location": "/#soc-support",
            "text": "If your SoC exposes it's I/O subsystems using the generic Linux kernel\ninterfaces then yes, libsoc supports your SoC!",
            "title": "SoC Support"
        },
        {
            "location": "/#language-support",
            "text": "The library is written in C and has a native C API. A subset of the API\nis also supported with Python bindings.",
            "title": "Language Support"
        },
        {
            "location": "/#c-api",
            "text": "Manual GPIO Manipulation through sysfs (Value, Edge, Direction, Exporting)  Blocking GPIO Interrupts with timeout  Non-blocking GPIO Interrupts with callback mechanism (pthread based)  SPI transfers using spidev  I2C transfers using ioctls  PWM support through sysfs (Linux 3.12+)  Automatic board probing via installed config files",
            "title": "C API"
        },
        {
            "location": "/#python-bindings",
            "text": "Manual GPIO Manipulation through sysfs (Value, Edge, Direction, Exporting)  Blocking GPIO Interrupts with timeout  Non-blocking GPIO Interrupts with callback mechanism  I2C transfers",
            "title": "Python Bindings"
        },
        {
            "location": "/#building",
            "text": "libsoc is built and installed using the autotools build system. This means it\nfollows the traditional linux methodology of autoreconf, configure, make.  First, check if your distro packages libsoc. If it does it is easiest to install\nyour distros version of libsoc through it's provided package manager. Depending\non your distro this may be  apt-get ,  yum ,  pacman , etc. Consult your distro\ndocumentation for more info.",
            "title": "Building"
        },
        {
            "location": "/#manually-building",
            "text": "First, make sure you have the prerequisites installed. Under Debian Jessie this\nmeans  build-essential ,  autoconf ,  libtool-bin  and  pkg-config . You'll also\nneed  python-dev  or  python3-dev , if you wish to install the python-bindings.  Then, clone libsoc from its git repository.  git clone https://github.com/jackmitch/libsoc.git libsoc.git  Enter the libsoc.git directory  cd libsoc.git  Run  autoreconf  to generate the libsoc configure scripts  autoreconf -i  Configure the libsoc library with the required features  ./configure\n\n    [--disable-debug]\n    [--enable-python=<path|version>]\n    [--enable-board=<board>]\n    [--with-board-configs]  --disable-debug\n\ndisables the debug code, turn off the debug to\nget the fastest operation but at the cost of any\ndebug print outs. Omitting this flag will leave\ndebug enabled.  --enable-python=<path|version>\n\nenable Python language bindings to libsoc API.\nValue can be empty for autodetect, the value 2\nor 3 to search the PATH environment variable\nfor python2 or python3, or an absolute path to\na python binary.  --enable-board=<board>\n\ninstall a specific board config file to\n$(sysdir)/libsoc.conf. This enables the use of\nthe board pin name lookup functions and\nautomatic board config probing. Supported boards\ncan be found under ./contrib/board_files. If\n--with-board-configs is also used, a symlink\nwill be created instead of copying a single file.  --with-board-configs\n\ninstall all the contributed board configuration\nfiles to $PREFIX/share/libsoc.  Compile the code using make  make  Install the library using make  make install",
            "title": "Manually Building"
        },
        {
            "location": "/#documentation",
            "text": "Written documentation can be found at http://jackmitch.github.io/libsoc .  Test cases can be found in the  test/  directory\nfrom the root of the project.  All functions and types are also documented directly in the code in the\napplication header files under lib/include .",
            "title": "Documentation"
        },
        {
            "location": "/#licencing",
            "text": "libsoc is licenced under the LGPLv2.1, please see the COPYING file for\nfurther details.",
            "title": "Licencing"
        },
        {
            "location": "/#contributing",
            "text": "libsoc is open-source software and as such you are welcome to browse the\ncode and either add features, or fix bugs. Please submit pull requests,\nand bugs to  libsoc@github .\nIf you have any comments or questions, I can be contacted by email at the\naddress  jack@embed.me.uk .",
            "title": "Contributing"
        },
        {
            "location": "/c/gpio/",
            "text": "GPIO\n\n\n\n\nData Types\n\n\n\n\ngpio_mode\n\n\nDetermines the way in which libsoc handles exporting and unexporting\nGPIOs in the Linux subsystem.\n\n\n\n\n\n\nLS_SHARED\n\n\nif the gpio is already exported then it will not unexport\nthe GPIO on free. If it is not exported, then it will\nunexport on free.\n\n\n\n\n\n\nLS_GREEDY\n\n\nwill succeed if the GPIO is already exported, but will \nalways unexport the GPIO on free.\n\n\n\n\n\n\nLS_WEAK\n\n\nwill fail if GPIO is already exported, will always unexport\non free.\n\n\n\n\n\n\n\n\ngpio_direction\n\n\nUsed for setting and reading the direction of the GPIO pin.\n\n\n\n\n\n\nDIRECTION_ERROR\n\n\nReturned when the GPIO direction could not be read\n\n\n\n\n\n\nINPUT\n\n\nGPIO input mode, it's input value can be read\n\n\n\n\n\n\nOUTPUT\n\n\nGPIO output mode, it's output value can be written\n\n\n\n\n\n\n\n\ngpio_level\n\n\nUsed for setting and reading the level of the GPIO pin.\n\n\n\n\n\n\nLEVEL_ERROR\n\n\nReturned when the GPIO level could not be read\n\n\n\n\n\n\nLOW\n\n\nGPIO value low, usually logic 0 on the pin, but could be 1 if\nthe gpio is inverted.\n\n\n\n\n\n\nHIGH\n\n\nGPIO value high, usually logic 1 on the pin, but could be 0 if\nthe gpio is inverted.\n\n\n\n\n\n\n\n\ngpio_edge\n\n\nUsed for setting and reading the edge of the GPIO pin.\n\n\n\n\n\n\nEDGE_ERROR\n\n\nReturned when the GPIO edge could not be read\n\n\n\n\n\n\nRISING\n\n\nGPIO interrupt is triggered on a rising edge, e.g. logic level\n0 followed by 1\n\n\n\n\n\n\nFALLING\n\n\nGPIO interrupt is triggered on a falling edge, e.g. logic level\n1 followed by 0\n\n\n\n\n\n\nNONE\n\n\nGPIO interrupt edge is not set\n\n\n\n\n\n\nBOTH\n\n\nGPIO interrupt is triggered on both a falling and rising edge\n\n\n\n\n\n\n\n\ngpio_int_ret\n\n\nReturn type for blocked GPIO interrupts.\n\n\n\n\n\n\nLS_INT_ERROR\n\n\nError condition\n\n\n\n\n\n\nLS_INT_TRIGGERED\n\n\nInterrupt was triggered\n\n\n\n\n\n\nLS_INT_TIMEOUT\n\n\nGPIO poll timedout\n\n\n\n\n\n\nFunctions\n\n\n\n\nlibsoc_gpio_request\n\n\ngpio * libsoc_gpio_request(unsigned int gpio_id, gpio_mode mode)\n\n\n\n\n\n\n\n\nunsigned int\n \ngpio_id\n\n\nthe Linux ID number for the GPIO you wish to use\n\n\n\n\n\n\ngpio_mode\n \nmode\n\n\nthe mode in which libsoc handles the GPIO file descriptor\n\n\n\n\n\n\nRequest a GPIO by it's Linux ID number and set the \ngpio_mode\n\nunder which libsoc will hold the file descriptor. Returns a malloced gpio struct\nwhich will need to be freed by \nlibsoc_gpio_free\n when no\nlonger needed.\n\n\nReturns \nNULL\n on failure.\n\n\n\n\nlibsoc_gpio_free\n\n\nint libsoc_gpio_free(gpio * gpio)\n\n\n\n\n\n\n\n\ngpioi*\n \ngpio\n\n\nthe previously requested gpio that you wish to release\n\n\n\n\n\n\nFree the memory associated with a previously requested GPIO and close the file\ndescriptors.\n\n\nReturns \nEXIT_SUCCESS\n/\nEXIT_FAILURE\n\n\n\n\nlibsoc_gpio_set_direction\n\n\nint libsoc_gpio_set_direction(gpio * current_gpio, gpio_direction direction)\n\n\n\n\n\n\n\n\ngpio*\n \ncurrent_gpio\n\n\nrequested gpio that you wish to set the direction of\n\n\n\n\n\n\ngpio_direction\n \ndirection\n\n\ndirection you wish to set the gpio to\n\n\n\n\n\n\nSet the direction of a GPIO, \nINPUT\n for reading a GPIO, \nOUTPUT\n for setting a\nGPIO.\n\n\nReturns \nEXIT_SUCCESS\n/\nEXIT_FAILURE\n\n\n\n\nlibsoc_gpio_get_direction\n\n\ngpio_direction libsoc_gpio_get_direction(gpio * current_gpio)\n\n\n\n\n\n\n\n\ngpio*\n \ncurrent_gpio\n\n\nrequested gpio that you wish to get the direction of\n\n\n\n\n\n\nGet the current \ngpio_direction\n of a requested GPIO.\n\n\nReturns \ngpio_direction\n, \nDIRECTION_ERROR\n on failure,\n\nINPUT\n/\nOUTPUT\n on success.\n\n\n\n\nlibsoc_gpio_set_level\n\n\nint libsoc_gpio_set_level(gpio * current_gpio, gpio_level level)\n\n\n\n\n\n\n\n\ngpio *\n \ncurrent_gpio\n\n\nrequested gpio you wish to set the level of\n\n\n\n\n\n\ngpio_level\n \nlevel\n\n\nlevel you wish to set the gpio to\n\n\n\n\n\n\nSet the output level of a requested GPIO to \nHIGH\n or \nLOW\n.\n\n\nReturns \nEXIT_SUCCESS\n/\nEXIT_FAILURE\n\n\n\n\nlibsoc_gpio_get_level\n\n\ngpio_level libsoc_gpio_get_level(gpio * current_gpio)\n\n\n\n\n\n\n\n\ngpio *\n \ncurrent_gpio\n\n\nrequested gpio you wish to get the level of\n\n\n\n\n\n\nGet the current \ngpio_level\n of a requested GPIO.\n\n\nReturns \ngpio_level\n, \nLEVEL_ERROR\n on failure,\n\nLOW\n/\nHIGH\n on success.\n\n\n\n\nlibsoc_gpio_set_edge\n\n\nint libsoc_gpio_set_edge(gpio * current_gpio, gpio_edge edge)\n\n\n\n\n\n\n\n\ngpio *\n \ncurrent_gpio\n\n\nrequested gpio you wish to set the edge of\n\n\n\n\n\n\ngpio_edge\n \nedge\n\n\nedge you wish to set the gpio to\n\n\n\n\n\n\nSet the edge type of a requested GPIO. The edge is the type of signal\nchange that will trigger interrupt detection. See \ngpio_edge\n\nfor explanations of the different types of edges and how they work.\n\n\nReturns \nEXIT_SUCCESS\n/\nEXIT_FAILURE\n\n\n\n\nlibsoc_gpio_get_edge\n\n\ngpio_edge libsoc_gpio_get_edge(gpio * current_gpio)\n\n\n\n\n\n\n\n\ngpio *\n \ncurrent_gpio\n\n\nrequested gpio you wish to get the edge of\n\n\n\n\n\n\nGet the current \ngpio_edge\n of a requested GPIO.\n\n\nReturns \ngpio_edge\n, \nEDGE_ERROR\n on failure,\n\nRISING\n/\nFALLING\n/\nBOTH\n/\nNONE\n on success.\n\n\n\n\nlibsoc_gpio_wait_interrupt\n\n\nint libsoc_gpio_wait_interrupt(gpio * gpio, int timeout)\n\n\n\n\n\n\n\n\ngpio *\n \ngpio\n\n\nrequested gpio you wish to wait for an interrupt on\n\n\n\n\n\n\nint\n \ntimeout\n\n\nthe number of seconds to wait for the interrupt, -1 for block indefinitly\n\n\n\n\n\n\nBlock for a set amount of seconds (or indefinitly) waiting for an interrupt on a\nGPIO to occur. If you wish to use a non-blocking interrupt mechanism see\n\nlibsoc_gpio_callback_interrupt\n.\n\n\nReturns \nLS_INT_ERROR\n on failure, \nLS_INT_TRIGGERED\n on captured interrupt,\n\nLS_INT_TIMEOUT\n if no interrupt was captured in the specified time.\n\n\n\n\nlibsoc_gpio_callback_interrupt\n\n\nint libsoc_gpio_callback_interrupt(gpio * gpio, int (*callback_fn) (void *), void *arg)\n\n\n\n\n\n\n\n\ngpio *\n \ngpio\n\n\nrequested gpio you wish to set an interrupt handler for\n\n\n\n\n\n\nint (*callback_fn) (void *)\n \nfunction\n\n\nname of the function to use as the interrupt handler. Must match the prototype\n\nint* function(void* ptr)\n\n\n\n\n\n\nvoid *\n \narg\n\n\nvoid casted pointer you wish to be passed to your interrupt handler\n\n\n\n\n\n\nSetup an interrupt handler on a GPIO. This will start a new pthread with an infinite poll\non the GPIO waiting for the interrupt. When an interrupt is detected the supplied function\nwill run in the thread, and then return to waiting for an interrupt.\n\n\nOnly one interrupt will be queued if it arrives while your supplied function is being run,\nso it is possible to miss interrupts if they happen too fast.\n\n\nReturns \nEXIT_SUCCESS\n/\nEXIT_FAILURE\n\n\n\n\nlibsoc_gpio_callback_interrupt_cancel\n\n\nint libsoc_gpio_callback_interrupt_cancel(gpio * gpio)\n\n\n\n\n\n\n\n\ngpio *\n \ngpio\n\n\nthe gpio on which to cancel a waiting interrupt handler\n\n\n\n\n\n\nCancel a previously set interrupt handler on a GPIO. This uses the pthread_cancel function,\nso it may cancel mid way through your interrupt handler function.\n\n\nReturns \nEXIT_SUCCESS\n/\nEXIT_FAILURE",
            "title": "GPIO"
        },
        {
            "location": "/c/gpio/#gpio",
            "text": "",
            "title": "GPIO"
        },
        {
            "location": "/c/gpio/#data-types",
            "text": "",
            "title": "Data Types"
        },
        {
            "location": "/c/gpio/#gpio_mode",
            "text": "Determines the way in which libsoc handles exporting and unexporting\nGPIOs in the Linux subsystem.    LS_SHARED  if the gpio is already exported then it will not unexport\nthe GPIO on free. If it is not exported, then it will\nunexport on free.    LS_GREEDY  will succeed if the GPIO is already exported, but will \nalways unexport the GPIO on free.    LS_WEAK  will fail if GPIO is already exported, will always unexport\non free.",
            "title": "gpio_mode"
        },
        {
            "location": "/c/gpio/#gpio_direction",
            "text": "Used for setting and reading the direction of the GPIO pin.    DIRECTION_ERROR  Returned when the GPIO direction could not be read    INPUT  GPIO input mode, it's input value can be read    OUTPUT  GPIO output mode, it's output value can be written",
            "title": "gpio_direction"
        },
        {
            "location": "/c/gpio/#gpio_level",
            "text": "Used for setting and reading the level of the GPIO pin.    LEVEL_ERROR  Returned when the GPIO level could not be read    LOW  GPIO value low, usually logic 0 on the pin, but could be 1 if\nthe gpio is inverted.    HIGH  GPIO value high, usually logic 1 on the pin, but could be 0 if\nthe gpio is inverted.",
            "title": "gpio_level"
        },
        {
            "location": "/c/gpio/#gpio_edge",
            "text": "Used for setting and reading the edge of the GPIO pin.    EDGE_ERROR  Returned when the GPIO edge could not be read    RISING  GPIO interrupt is triggered on a rising edge, e.g. logic level\n0 followed by 1    FALLING  GPIO interrupt is triggered on a falling edge, e.g. logic level\n1 followed by 0    NONE  GPIO interrupt edge is not set    BOTH  GPIO interrupt is triggered on both a falling and rising edge",
            "title": "gpio_edge"
        },
        {
            "location": "/c/gpio/#gpio_int_ret",
            "text": "Return type for blocked GPIO interrupts.    LS_INT_ERROR  Error condition    LS_INT_TRIGGERED  Interrupt was triggered    LS_INT_TIMEOUT  GPIO poll timedout",
            "title": "gpio_int_ret"
        },
        {
            "location": "/c/gpio/#functions",
            "text": "",
            "title": "Functions"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_request",
            "text": "gpio * libsoc_gpio_request(unsigned int gpio_id, gpio_mode mode)    unsigned int   gpio_id  the Linux ID number for the GPIO you wish to use    gpio_mode   mode  the mode in which libsoc handles the GPIO file descriptor    Request a GPIO by it's Linux ID number and set the  gpio_mode \nunder which libsoc will hold the file descriptor. Returns a malloced gpio struct\nwhich will need to be freed by  libsoc_gpio_free  when no\nlonger needed.  Returns  NULL  on failure.",
            "title": "libsoc_gpio_request"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_free",
            "text": "int libsoc_gpio_free(gpio * gpio)    gpioi*   gpio  the previously requested gpio that you wish to release    Free the memory associated with a previously requested GPIO and close the file\ndescriptors.  Returns  EXIT_SUCCESS / EXIT_FAILURE",
            "title": "libsoc_gpio_free"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_set_direction",
            "text": "int libsoc_gpio_set_direction(gpio * current_gpio, gpio_direction direction)    gpio*   current_gpio  requested gpio that you wish to set the direction of    gpio_direction   direction  direction you wish to set the gpio to    Set the direction of a GPIO,  INPUT  for reading a GPIO,  OUTPUT  for setting a\nGPIO.  Returns  EXIT_SUCCESS / EXIT_FAILURE",
            "title": "libsoc_gpio_set_direction"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_get_direction",
            "text": "gpio_direction libsoc_gpio_get_direction(gpio * current_gpio)    gpio*   current_gpio  requested gpio that you wish to get the direction of    Get the current  gpio_direction  of a requested GPIO.  Returns  gpio_direction ,  DIRECTION_ERROR  on failure, INPUT / OUTPUT  on success.",
            "title": "libsoc_gpio_get_direction"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_set_level",
            "text": "int libsoc_gpio_set_level(gpio * current_gpio, gpio_level level)    gpio *   current_gpio  requested gpio you wish to set the level of    gpio_level   level  level you wish to set the gpio to    Set the output level of a requested GPIO to  HIGH  or  LOW .  Returns  EXIT_SUCCESS / EXIT_FAILURE",
            "title": "libsoc_gpio_set_level"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_get_level",
            "text": "gpio_level libsoc_gpio_get_level(gpio * current_gpio)    gpio *   current_gpio  requested gpio you wish to get the level of    Get the current  gpio_level  of a requested GPIO.  Returns  gpio_level ,  LEVEL_ERROR  on failure, LOW / HIGH  on success.",
            "title": "libsoc_gpio_get_level"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_set_edge",
            "text": "int libsoc_gpio_set_edge(gpio * current_gpio, gpio_edge edge)    gpio *   current_gpio  requested gpio you wish to set the edge of    gpio_edge   edge  edge you wish to set the gpio to    Set the edge type of a requested GPIO. The edge is the type of signal\nchange that will trigger interrupt detection. See  gpio_edge \nfor explanations of the different types of edges and how they work.  Returns  EXIT_SUCCESS / EXIT_FAILURE",
            "title": "libsoc_gpio_set_edge"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_get_edge",
            "text": "gpio_edge libsoc_gpio_get_edge(gpio * current_gpio)    gpio *   current_gpio  requested gpio you wish to get the edge of    Get the current  gpio_edge  of a requested GPIO.  Returns  gpio_edge ,  EDGE_ERROR  on failure, RISING / FALLING / BOTH / NONE  on success.",
            "title": "libsoc_gpio_get_edge"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_wait_interrupt",
            "text": "int libsoc_gpio_wait_interrupt(gpio * gpio, int timeout)    gpio *   gpio  requested gpio you wish to wait for an interrupt on    int   timeout  the number of seconds to wait for the interrupt, -1 for block indefinitly    Block for a set amount of seconds (or indefinitly) waiting for an interrupt on a\nGPIO to occur. If you wish to use a non-blocking interrupt mechanism see libsoc_gpio_callback_interrupt .  Returns  LS_INT_ERROR  on failure,  LS_INT_TRIGGERED  on captured interrupt, LS_INT_TIMEOUT  if no interrupt was captured in the specified time.",
            "title": "libsoc_gpio_wait_interrupt"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_callback_interrupt",
            "text": "int libsoc_gpio_callback_interrupt(gpio * gpio, int (*callback_fn) (void *), void *arg)    gpio *   gpio  requested gpio you wish to set an interrupt handler for    int (*callback_fn) (void *)   function  name of the function to use as the interrupt handler. Must match the prototype int* function(void* ptr)    void *   arg  void casted pointer you wish to be passed to your interrupt handler    Setup an interrupt handler on a GPIO. This will start a new pthread with an infinite poll\non the GPIO waiting for the interrupt. When an interrupt is detected the supplied function\nwill run in the thread, and then return to waiting for an interrupt.  Only one interrupt will be queued if it arrives while your supplied function is being run,\nso it is possible to miss interrupts if they happen too fast.  Returns  EXIT_SUCCESS / EXIT_FAILURE",
            "title": "libsoc_gpio_callback_interrupt"
        },
        {
            "location": "/c/gpio/#libsoc_gpio_callback_interrupt_cancel",
            "text": "int libsoc_gpio_callback_interrupt_cancel(gpio * gpio)    gpio *   gpio  the gpio on which to cancel a waiting interrupt handler    Cancel a previously set interrupt handler on a GPIO. This uses the pthread_cancel function,\nso it may cancel mid way through your interrupt handler function.  Returns  EXIT_SUCCESS / EXIT_FAILURE",
            "title": "libsoc_gpio_callback_interrupt_cancel"
        },
        {
            "location": "/c/spi/",
            "text": "",
            "title": "SPI (WIP)"
        },
        {
            "location": "/c/i2c/",
            "text": "I2C\n\n\n\n\nFunctions\n\n\n\n\nlibsoc_i2c_init\n\n\ni2c* libsoc_i2c_init (uint8_t i2c_bus, uint8_t i2c_address)\n\n\n\n\n\n\n\n\nuint8_t\n \ni2c_bus\n\n\nthe linux enumerated bus number\n\n\n\n\n\n\nuint8_t\n \ni2c_address\n\n\nthe peripherals address on the i2c bus\n\n\n\n\n\n\nInitialises a new i2c instance at the specificed address. Returns a\nmalloced i2c struct which must be freed with\n\nlibsoc_i2c_free\n when no longer needed.\n\n\nReturns \nNULL\n on failure.\n\n\n\n\nlibsoc_i2c_free\n\n\nint libsoc_i2c_free (i2c * i2c)\n\n\n\n\n\n\n\n\ni2c*\n \ni2c\n\n\npreviously initialised i2c struct\n\n\n\n\n\n\nFree the memory associated with a previously initialised i2c struct and release\nthe hold on the i2c address.\n\n\nReturns \nEXIT_SUCCESS\n or \nEXIT_FAILURE\n\n\n\n\nlibsoc_i2c_write\n\n\nint libsoc_i2c_write (i2c * i2c, uint8_t * buffer, uint16_t len)\n\n\n\n\n\n\n\n\ni2c*\n \ni2c\n\n\npreviously initialised i2c struct\n\n\n\n\n\n\nuint8_t*\n \nbuffer\n\n\npointer to output data buffer\n\n\n\n\n\n\nuint16_t\n \nlen\n\n\nlength of data to write in bytes\n\n\n\n\n\n\nWrite \nlen\n bytes starting from the \nbuffer\n data pointer to the specified\ni2c device.\n\n\nReturns \nEXIT_SUCCESS\n or \nEXIT_FAILURE\n\n\n\n\nlibsoc_i2c_read\n\n\nint libsoc_i2c_read (i2c * i2c, uint8_t * buffer, uint16_t len)\n\n\n\n\n\n\n\n\ni2c*\n \ni2c\n\n\npreviously initialised i2c struct\n\n\n\n\n\n\nuint8_t*\n \nbuffer\n\n\npointer to input data buffer\n\n\n\n\n\n\nuint16_t\n \nlen\n\n\nlength of data to read in bytes\n\n\n\n\n\n\nRead \nlen\n bytes into the \nbuffer\n data pointer from the specified\ni2c device.\n\n\nReturns \nEXIT_SUCCESS\n or \nEXIT_FAILURE\n\n\n\n\nlibsoc_i2c_set_timeout\n\n\nint libsoc_i2c_set_timeout(i2c * i2c, int timeout)\n\n\n\n\n\n\n\n\ni2c*\n \ni2c\n\n\npreviously initialised i2c struct\n\n\n\n\n\n\nint\n \ntimeout\n\n\ni2c timeout in milliseconds/10\n\n\n\n\n\n\nSet the timeout of a i2c device in milliseconds/10. For example if a timeout of\n20ms is requred, \ntimeout\n would be set to 2.\n\n\n    // 20ms timeout, 2*10ms\n    libsoc_i2c_set_timeout(device, 2);\n\n\n\n\nReturns \nEXIT_SUCCESS\n or \nEXIT_FAILURE",
            "title": "I2C"
        },
        {
            "location": "/c/i2c/#i2c",
            "text": "",
            "title": "I2C"
        },
        {
            "location": "/c/i2c/#functions",
            "text": "",
            "title": "Functions"
        },
        {
            "location": "/c/i2c/#libsoc_i2c_init",
            "text": "i2c* libsoc_i2c_init (uint8_t i2c_bus, uint8_t i2c_address)    uint8_t   i2c_bus  the linux enumerated bus number    uint8_t   i2c_address  the peripherals address on the i2c bus    Initialises a new i2c instance at the specificed address. Returns a\nmalloced i2c struct which must be freed with libsoc_i2c_free  when no longer needed.  Returns  NULL  on failure.",
            "title": "libsoc_i2c_init"
        },
        {
            "location": "/c/i2c/#libsoc_i2c_free",
            "text": "int libsoc_i2c_free (i2c * i2c)    i2c*   i2c  previously initialised i2c struct    Free the memory associated with a previously initialised i2c struct and release\nthe hold on the i2c address.  Returns  EXIT_SUCCESS  or  EXIT_FAILURE",
            "title": "libsoc_i2c_free"
        },
        {
            "location": "/c/i2c/#libsoc_i2c_write",
            "text": "int libsoc_i2c_write (i2c * i2c, uint8_t * buffer, uint16_t len)    i2c*   i2c  previously initialised i2c struct    uint8_t*   buffer  pointer to output data buffer    uint16_t   len  length of data to write in bytes    Write  len  bytes starting from the  buffer  data pointer to the specified\ni2c device.  Returns  EXIT_SUCCESS  or  EXIT_FAILURE",
            "title": "libsoc_i2c_write"
        },
        {
            "location": "/c/i2c/#libsoc_i2c_read",
            "text": "int libsoc_i2c_read (i2c * i2c, uint8_t * buffer, uint16_t len)    i2c*   i2c  previously initialised i2c struct    uint8_t*   buffer  pointer to input data buffer    uint16_t   len  length of data to read in bytes    Read  len  bytes into the  buffer  data pointer from the specified\ni2c device.  Returns  EXIT_SUCCESS  or  EXIT_FAILURE",
            "title": "libsoc_i2c_read"
        },
        {
            "location": "/c/i2c/#libsoc_i2c_set_timeout",
            "text": "int libsoc_i2c_set_timeout(i2c * i2c, int timeout)    i2c*   i2c  previously initialised i2c struct    int   timeout  i2c timeout in milliseconds/10    Set the timeout of a i2c device in milliseconds/10. For example if a timeout of\n20ms is requred,  timeout  would be set to 2.      // 20ms timeout, 2*10ms\n    libsoc_i2c_set_timeout(device, 2);  Returns  EXIT_SUCCESS  or  EXIT_FAILURE",
            "title": "libsoc_i2c_set_timeout"
        },
        {
            "location": "/c/pwm/",
            "text": "PWM\n\n\n\n\nData Types\n\n\n\n\nshared_mode\n\n\nDetermines the way in which libsoc handles exporting and unexporting\nPWMs in the Linux subsystem.\n\n\n\n\n\n\nLS_SHARED\n\n\nif the pwm is already exported then it will not unexport\nthe pwm on free. If it is not exported, then it will\nunexport on free.\n\n\n\n\n\n\nLS_GREEDY\n\n\nwill succeed if the pwm is already exported, but will\nalways unexport the pwm on free.\n\n\n\n\n\n\nLS_WEAK\n\n\nwill fail if pwm is already exported, will always unexport\non free.\n\n\n\n\n\n\npwm_enabled\n\n\nUsed for setting and reading the enabled state of the PWM device\n\n\n\n\n\n\nENABLED_ERROR\n\n\nReturned when the enabled state could not be read\n\n\n\n\n\n\nDISABLED\n\n\nPWM disabled mode, the pwm is not currently running\n\n\n\n\n\n\nENABLED\n\n\nPWM enabled mode, the pwm is currently running\n\n\n\n\n\n\n\n\npwm_polarity\n\n\nUsed for setting and reading the polarity of the PWM device\n\n\n\n\n\n\nPOLARITY_ERROR\n\n\nReturned when the polarity could not be read\n\n\n\n\n\n\nNORMAL\n\n\nPolarity mode is normal\n\n\n\n\n\n\nINVERSED\n\n\nPolarity mode is inversed\n\n\n\n\n\n\nFunctions\n\n\n\n\nlibsoc_pwm_request\n\n\npwm* libsoc_pwm_request(unsigned int pwm_chip, unsigned int pwm_num, enum shared_mode mode)\n\n\n\n\n\n\n\n\nunsigned int\n \npwm_chip\n\n\nthe pwm chip number which controls the pwm you wish to use\n\n\n\n\n\n\nunsigned int\n \npwm_num\n\n\nthe pwm number within your specified pwm chip\n\n\n\n\n\n\nshared_mode\n \nmode\n\n\nthe mode in which libsoc handles the PWM file descriptor\n\n\n\n\n\n\nRequest a pwm by specifying its pwm chip number and the pwm number it is on that chip.\nSet \nshared_mode\n to handle how libsoc manages the file descriptor.\nReturns a malloced pwm struct which will need to be freed by \nlibsoc_pwm_free\n\nwhen no longer needed.\n\n\n\n\nlibsoc_pwm_free\n\n\nint libsoc_pwm_free(pwm *pwm)\n\n\n\n\n\n\n\n\npwm*\n \npwm\n\n\nthe previously requested pwm that you wish to release\n\n\n\n\n\n\nFree the memory associated with a previously requested PWM device and close the file\ndescriptors.\n\n\n\n\nlibsoc_pwm_set_enabled\n\n\nint libsoc_pwm_set_enabled(pwm *pwm, pwm_enabled enabled)\n\n\n\n\n\n\n\n\npwm*\n \npwm\n\n\nrequested pwm that you wish to set enabled/disabled\n\n\n\n\n\n\npwm_enabled\n \nenabled\n\n\nstate you wish to set the pwm device to\n\n\n\n\n\n\nSet the state of a PWM device, \nENABLED\n to enable to the device, \nDISABLED\n to\ndisable the device.\n\n\n\n\nlibsoc_pwm_get_enabled\n\n\npwm_enabled libsoc_pwm_get_enabled(pwm *pwm)\n\n\n\n\n\n\n\n\npwm*\n \npwm\n\n\nrequested pwm that you wish to get the state of\n\n\n\n\n\n\nGet the current \npwm_enabled\n state of a requested PWM device.\n\n\n\n\nlibsoc_pwm_set_period\n\n\nint libsoc_pwm_set_period(pwm *pwm, unsigned int period)\n\n\n\n\n\n\n\n\npwm*\n \npwm\n\n\nrequested pwm that you wish to set the period of\n\n\n\n\n\n\nunsigned int\n \nperiod\n\n\nthe total period of the pwm signal in nanoseconds\n\n\n\n\n\n\nSet the period of a PWM device, the value is specified in nanoseconds and is the sum\nof the active and inactive time of the signal.\n\n\n\n\nlibsoc_pwm_get_period\n\n\nint libsoc_pwm_get_period(pwm *pwm)\n\n\n\n\n\n\n\n\npwm*\n \npwm\n\n\nrequested pwm that you wish to get the period of\n\n\n\n\n\n\nGet the currently set perioid of the PWM device in nanoseconds.\n\n\n\n\nlibsoc_pwm_set_duty_cycle\n\n\nint libsoc_pwm_set_duty_cycle(pwm *pwm, unsigned int duty)\n\n\n\n\n\n\n\n\npwm*\n \npwm\n\n\nrequested pwm that you wish to set the duty cycle of\n\n\n\n\n\n\nunsigned int\n \nduty\n\n\nthe duty cycle in nanoseconds\n\n\n\n\n\n\nSet the duty cycle of the specified PWM device in nanoseconds. The duty cycle is the\nactive time of the PWM signal and must be less than the period.\n\n\n\n\nlibsoc_pwm_get_duty_cycle\n\n\nint libsoc_pwm_get_duty_cycle(pwm *pwm)\n\n\n\n\n\n\n\n\npwm*\n \npwm\n\n\nrequested pwm that you wish to get the duty cycle of\n\n\n\n\n\n\nGet the currently set duty cycle of a requested PWM device in nanoseconds.\n\n\n\n\nlibsoc_pwm_set_polarity\n\n\nint libsoc_pwm_set_polarity(pwm *pwm, pwm_polarity polarity)\n\n\n\n\n\n\n\n\npwm*\n \npwm\n\n\nrequested pwm that you wish to set the polarity of\n\n\n\n\n\n\npwm_polarity\n \npolarity\n\n\npolarity you wish to set the pwm device to\n\n\n\n\n\n\nSet the polarity of a PWM device, \nNORMAL\n will give you the default polarity,\n\nINVERSED\n will give you the inverse polarity of normal.\n\n\nPolarity support is optional, ensure your PWM devices kernel driver is capable before\nrelying on this support. The value -1 will be returned on failure to set the polarity.\n\n\n\n\nlibsoc_pwm_get_polarity\n\n\npwm_polarity libsoc_pwm_get_polarity(pwm *pwm)\n\n\n\n\n\n\n\n\npwm*\n \npwm\n\n\nrequested pwm that you wish to get the polarity of\n\n\n\n\n\n\nGet the current \npwm_polarity\n of a requested PWM device.",
            "title": "PWM"
        },
        {
            "location": "/c/pwm/#pwm",
            "text": "",
            "title": "PWM"
        },
        {
            "location": "/c/pwm/#data-types",
            "text": "",
            "title": "Data Types"
        },
        {
            "location": "/c/pwm/#shared_mode",
            "text": "Determines the way in which libsoc handles exporting and unexporting\nPWMs in the Linux subsystem.    LS_SHARED  if the pwm is already exported then it will not unexport\nthe pwm on free. If it is not exported, then it will\nunexport on free.    LS_GREEDY  will succeed if the pwm is already exported, but will\nalways unexport the pwm on free.    LS_WEAK  will fail if pwm is already exported, will always unexport\non free.",
            "title": "shared_mode"
        },
        {
            "location": "/c/pwm/#pwm_enabled",
            "text": "Used for setting and reading the enabled state of the PWM device    ENABLED_ERROR  Returned when the enabled state could not be read    DISABLED  PWM disabled mode, the pwm is not currently running    ENABLED  PWM enabled mode, the pwm is currently running",
            "title": "pwm_enabled"
        },
        {
            "location": "/c/pwm/#pwm_polarity",
            "text": "Used for setting and reading the polarity of the PWM device    POLARITY_ERROR  Returned when the polarity could not be read    NORMAL  Polarity mode is normal    INVERSED  Polarity mode is inversed",
            "title": "pwm_polarity"
        },
        {
            "location": "/c/pwm/#functions",
            "text": "",
            "title": "Functions"
        },
        {
            "location": "/c/pwm/#libsoc_pwm_request",
            "text": "pwm* libsoc_pwm_request(unsigned int pwm_chip, unsigned int pwm_num, enum shared_mode mode)    unsigned int   pwm_chip  the pwm chip number which controls the pwm you wish to use    unsigned int   pwm_num  the pwm number within your specified pwm chip    shared_mode   mode  the mode in which libsoc handles the PWM file descriptor    Request a pwm by specifying its pwm chip number and the pwm number it is on that chip.\nSet  shared_mode  to handle how libsoc manages the file descriptor.\nReturns a malloced pwm struct which will need to be freed by  libsoc_pwm_free \nwhen no longer needed.",
            "title": "libsoc_pwm_request"
        },
        {
            "location": "/c/pwm/#libsoc_pwm_free",
            "text": "int libsoc_pwm_free(pwm *pwm)    pwm*   pwm  the previously requested pwm that you wish to release    Free the memory associated with a previously requested PWM device and close the file\ndescriptors.",
            "title": "libsoc_pwm_free"
        },
        {
            "location": "/c/pwm/#libsoc_pwm_set_enabled",
            "text": "int libsoc_pwm_set_enabled(pwm *pwm, pwm_enabled enabled)    pwm*   pwm  requested pwm that you wish to set enabled/disabled    pwm_enabled   enabled  state you wish to set the pwm device to    Set the state of a PWM device,  ENABLED  to enable to the device,  DISABLED  to\ndisable the device.",
            "title": "libsoc_pwm_set_enabled"
        },
        {
            "location": "/c/pwm/#libsoc_pwm_get_enabled",
            "text": "pwm_enabled libsoc_pwm_get_enabled(pwm *pwm)    pwm*   pwm  requested pwm that you wish to get the state of    Get the current  pwm_enabled  state of a requested PWM device.",
            "title": "libsoc_pwm_get_enabled"
        },
        {
            "location": "/c/pwm/#libsoc_pwm_set_period",
            "text": "int libsoc_pwm_set_period(pwm *pwm, unsigned int period)    pwm*   pwm  requested pwm that you wish to set the period of    unsigned int   period  the total period of the pwm signal in nanoseconds    Set the period of a PWM device, the value is specified in nanoseconds and is the sum\nof the active and inactive time of the signal.",
            "title": "libsoc_pwm_set_period"
        },
        {
            "location": "/c/pwm/#libsoc_pwm_get_period",
            "text": "int libsoc_pwm_get_period(pwm *pwm)    pwm*   pwm  requested pwm that you wish to get the period of    Get the currently set perioid of the PWM device in nanoseconds.",
            "title": "libsoc_pwm_get_period"
        },
        {
            "location": "/c/pwm/#libsoc_pwm_set_duty_cycle",
            "text": "int libsoc_pwm_set_duty_cycle(pwm *pwm, unsigned int duty)    pwm*   pwm  requested pwm that you wish to set the duty cycle of    unsigned int   duty  the duty cycle in nanoseconds    Set the duty cycle of the specified PWM device in nanoseconds. The duty cycle is the\nactive time of the PWM signal and must be less than the period.",
            "title": "libsoc_pwm_set_duty_cycle"
        },
        {
            "location": "/c/pwm/#libsoc_pwm_get_duty_cycle",
            "text": "int libsoc_pwm_get_duty_cycle(pwm *pwm)    pwm*   pwm  requested pwm that you wish to get the duty cycle of    Get the currently set duty cycle of a requested PWM device in nanoseconds.",
            "title": "libsoc_pwm_get_duty_cycle"
        },
        {
            "location": "/c/pwm/#libsoc_pwm_set_polarity",
            "text": "int libsoc_pwm_set_polarity(pwm *pwm, pwm_polarity polarity)    pwm*   pwm  requested pwm that you wish to set the polarity of    pwm_polarity   polarity  polarity you wish to set the pwm device to    Set the polarity of a PWM device,  NORMAL  will give you the default polarity, INVERSED  will give you the inverse polarity of normal.  Polarity support is optional, ensure your PWM devices kernel driver is capable before\nrelying on this support. The value -1 will be returned on failure to set the polarity.",
            "title": "libsoc_pwm_set_polarity"
        },
        {
            "location": "/c/pwm/#libsoc_pwm_get_polarity",
            "text": "pwm_polarity libsoc_pwm_get_polarity(pwm *pwm)    pwm*   pwm  requested pwm that you wish to get the polarity of    Get the current  pwm_polarity  of a requested PWM device.",
            "title": "libsoc_pwm_get_polarity"
        },
        {
            "location": "/c/debug/",
            "text": "",
            "title": "DEBUG (WIP)"
        },
        {
            "location": "/python/",
            "text": "",
            "title": "Python Bindings (WIP)"
        }
    ]
}